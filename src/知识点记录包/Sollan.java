package 知识点记录包; 
/**
 * @author 16190
 *
 */
public class Sollan {
	/*
	 * 1.类的数据：静态、成员、局部变量,静态、构造、成员方法,静态、普通代码块。
	 * 2.构造方法和对象的创建有关，在没有自己设置构造方法时，系统会默认一个空的构造方法
	 * 3.修饰符有public、protected、private;static、final;abstract、extends、interface、implements 
	 * 4.static静态，静态成员不能直接访问非静态成员 
	 * 5.static修饰的方法中不能使用this、super引用，static修饰的方法不能访问非static修饰的普通成员
	 * 6.变量分为 局部变量 和 成员变量 成员变量分为 实例变量 和 类变量 局部变量分为 形参 方法内定义的局部变量 代码块中定义的局部变量
	 * 7.局部变量不能用权限修饰符修饰。
	 * 8.抽象类(abstract修饰)不能创建实例，也就是不能new
	 * 9.继承：子类可以使用父类所有public修饰的方法和变量，父类被覆盖掉的方法、变量和构造方法需要super语句来调用。 
	 * 10.多态：将父类对象应用于子类的特征就是多态。
	 * 
	 * 
	 * JDK1.2 Java2 JDK1.5 J2 SE5.0 JDK1.6 Java SE6.0 
	 * javaScript一种嵌入到网页中的脚本语言，和JAVA没有任何关系。
	 * 
	 * Java的编码:
	 * 1.使用Unicode编码,Unicode所定义的国际化字符集包含所有国家的文字及字符的编码。
	 * 2.java中的char是用16位表示的。在ASCII码中char用8位表示。
	 * 
	 * 
	 * 转义字符:
	 * 1.	\'			单引号
	 * 2.	\''			双引号
	 * 3.	\\			反斜杠
	 * 4.	\r			回车
	 * 5.	\n			换行
	 * 6.	\f			走纸
	 * 7.	\t			水平制表
	 * 8.	\b			退格
	 * 9.	\ddd		用八进制表示字符
	 * 10.	\ uxxxx		用十六进制表示字符
	 * 
	 * 逻辑运算符:
	 * 1.【&&、||】 与【 &、|】 的区别:在计算【a&&b】时，如果a等于false,则不用判断b的值即可得出结论;在计算【a&b】时,会判断a和b的值，然后再进行【与】运算
	 * 
	 * 栈和堆:
	 * 1.栈：存放【指令】程序，存取速度快，仅次于寄存器，数据可共享。
	 * 2.堆:存放【数据】，能动态分配内存大小，无用的数据会被垃圾回收机制自动回收处理。存取速度较慢。
	 *   
	 * 对象：
	 * Car c1=new Car();
	 * Car c2=new Car();
	 * 1.在程序中定义的Car类的变量c1、c2只是一个【引用】，他们被存放在【栈】内存中，而实际的Car对象只有一个，存放在【堆】内存中。通过赋值操作c2=c1，使c2、c1都【指向】堆内存中存储的Car对象(地址)。
	 * 2.实际的Car对象是它类里面定义的一堆变量和方法
	 * 3.c2、c1都【指向】堆内存中存储的Car对象(地址)，但它们的操作互不影响 :如果利用c1改变了Car的某变量,c2访问时它依旧是原来的值。
	 * 4.可以理解为c1访问Car对象时这些对象都copy了一份出来进行操作，c2访问时也copy，不过模板还是原来的对象。
	 * 
	 * 访问控制符:
	 * 1.private、default、protected、public
	 * 2.private:私有的，访问【同类】数据
	 * 3.default:默认权限控制符，访问【同包】数据
	 * 4.protected:【同包】及其不同包的【子类】可访问
	 * 5.public:同一个工程下均可访问，最大的权限
	 * 6.外部类只能用public、defult修饰;内部类能用public、protected、defult、private修饰
	 * 
	 * 方法重载: 
	 * 同一类中方法名相同，形参列表不同。与修饰符返回值无关，可改。 
	 * 方法重写:
	 * 子类重写父类中返回值、方法名、形参列表均相同的方法内容，访问权限不得小于父类所定义的权限。
	 * 
	 * 类的继承: 
	 * 1.子类可以把父类中的（非private修饰）的变量及方法当成自己的使用(构造方法除外)。
	 * 2.父类中private修饰的方法子类无法访问、改写。
	 * 3.重写父类的方法不能改变方法名、形参列表及返回值类型，访问权限应大于或等于父类原方法。改写父类方法的内容。
	 * 4.子类对象无法访问父类被覆盖的方法，需用super才能调用。
	 * 5.super――直接父类的默认引用，可以被视为直接父类的一个对象。super.fly()；调用直接父类被覆盖的fly()方法。要调用被覆盖的父类方法时可用。
	 * 6.super不能出现在static修饰的方法中。 
	 * 7.变量属性也与方法一样使用以上法则。
	 * 8.在子类中调用父类的构造方法，用super（size，name）；的形式（调用了含两个参数的构造方法）。该语句必须写在子类构造方法的第一句。
	 * 9.在子类初次创建实例对象时，会从最高父类开始初始化操作，所有父类的构造方法都会从上至下运行。
	 * 
	 * 类的多态：
	 * 1.必须有继承关系发生
	 * 2.父类的引用指向子类对象  Animal an=new Dog();
	 * 3.父类的引用an可以用来装各种Animal子类的对象
	 * 4.可用Animal类型的形参传入任意子类对象进行运用
	 * 
	 * equals与"=="的区别：
	 *	1.object类中原始的equals方法是用作比较地址的。例如StringBiuder、StringBuffer类没有重写equals(),所以只能用于比较地址。
	 *	2.基本包装类（Boolean、Integer、String…）重写了equals方法，使其能比较值是否相等。
	 *	3."=="用于比较地址是否相同，基本数据类型(int i=1;)只能用"=="来比较。
	 *	4.	Integer n1 = new Integer(30); 
	 *		Integer n2 = new Integer(30); 
	 *		Integer n3 = new Integer(31); 
	 *		System.out.println(n1 == n2);//结果是false 两个不同的Integer对象，故其地址不同， 
	 *		System.out.println(n1 == n3);//那么不管是new Integer(30)还是new Integer(31) 结果都显示false 
	 *		System.out.println(n1.equals(n2));//结果是true 根据jdk文档中的说明，n1与n2指向的对象中的内容是相等的，都是30，故equals比较后结果是true 
	 *		System.out.println(n1.equals(n3));//结果是false 因对象内容不一样，一个是30一个是31 
	 * 
	 * 
	 * 

	 * 向上转型: 
	 * Father a＝new Child();  a.show();           
	 * 1.a是父类的一个引用
	 * 2.对象a是指向Child类的，a在功能上能调用子类中和父类同名的的方法，并遗失子类中父类没有的方法(看做Child的对象)。
	 * 3.a能调用父类的方法，若某方法被子类覆盖，则调用覆盖后的方法(看做Father的对象)。
	 * 
	 * static静态：
	 * 1.[静态]方法不能调用[成员]方法、变量，只能通过[对象]访问
	 * 2.[静态]方法可以调用[静态]变量、方法
	 * 3.[成员]变量可以调用[静态]变量、方法,方式为【类名】.【静态方法、变量】 Person.count
	 * 4.static修饰的[静态方法]直属于[类]
	 * 5.[成员]方法及成员变量直属于[某对象],类高于对象
	 * 6.Calendar c=Calendar.getInstance(); 获取一个[特别类]的对象，这个特殊类不能new出对象 特别类指抽象类、接口
	 * 7.程序运行顺序：
	 *1).静态代码块、静态变量――(同等级,谁在前面就先运行谁)
	 *2).成员变量、实例代码块――(同等级,谁在前面就先运行谁)
	 *3).构造方法
	 * 
	 * 抽象类: 
	 * 1.修饰符abstract 
	 * 2.有抽象方法的类必为抽象类，抽象类不一定有抽象方法。
	 * 3.抽象方法没有方法体，需要被子类重写。
	 * 4.抽象类无法new 创建实例，构造方法主要用于被子类调用。
	 * 5.抽象类中可包含 变量、方法(普通或抽象)、构造方法、初始化块、内部类、枚举类。
	 * 6.抽象类主要用于被继承，由子类实现其功能。
	 * 7.abstract只能用于修饰方法(构造方法除外)和类，不能同static同时修饰某个方法。
	 * 
	 * 接口: 
	 * 1.关键字interface、implements 
	 * 2.用public修饰的接口可被任何其他接口或类访问，默认修饰符只能被本包内类与接口访问。
	 * 3.接口的成员变量都是共有、静态、最终的常量。
	 * 4.接口中的方法都是共有的、抽象的，无方法体，继承接口的类需完全实现这些方法，不然此类也必须声明为抽象类。
	 * 5.接口可同时继承多个接口。 
	 * 6.接口中不能有静态的方法、构造方法、初始化块。
	 * 
	 * 设计模式：
	 * 1.单例设计模式:将类的构造方法、成员变量【隐藏】，通过一个static方法创建一个对象，其他类【只能】通过这个方法创建本类的对象
	 * 	   当且仅当系统中【只能保留一个对象】时使用。静态方法
	 * 
	 * 
	 * 变量:
	 * 成员变量→实例变量(非static修饰)、类变量(static修饰)
	 * 局部变量→形参、方法内局部变量、代码快中局部变量
	 * 
	 * this关键字:
	 * 1.  this.name=name;
	 * 用于区分成员变量和局部变量
	 * 2.  this.run(highspeed);
	 * 用于调用本类中的run方法，可用在构造方法和普通方法中使用。
	 * 3.  this("白马",100);
	 * 用于在构造方法中调用本类中另一个构造方法，调用构造方法的语句必须写在构造方法的第一句。
	 * 
	 * break 与  continue
	 * break:跳出循环，结束循环。跳出switch语句，中断与下一个case的比较。
	 * continue：结束后面的程序语句，并回到循环语句开头，进行下一次循环。
	 * 
	 * JAVA编码方式:
	 * 1.一个字节==8位二进制数
	 * 2.一个英文字符==一个字节
	 * 3.一个中文字符==两个字节
	 * 4.Java中的byte占用一个字节，内层使用UTF-16编码
	 * 5.Java中的char占用两个字节，内层使用UTF-16编码
	 * 6.IO流读取【中文】与【英文】时，字符是byte类型的，而不是char类型的。
	 * 
	 * 
	 * IO流：
	 * 1.Writer、Reader属于字符流,可以直接读(写)出字符、字符串数据
	 * 2.OutputStream、InputStream属于字节流,读(写)出的数据是编码的形式。
	 * 3.两种流可以用InputStremReader s = new InputStremReader(out.getInputStream);来转换
	 * 4.BufferedReader的readLine()方法：读取一个文本行，没有读到换行符则进入类似阻塞状态。通过下列字符之一即可认为某行已终止：换行 ('\n')、回车 ('\r') 或回车后直接跟着换行。
	 * 5.BufferedWriter的write()方法：写入一个字符串，但必须使用newLine()方法在文本末添加换行符才能被readLine()读取。 
	 * 6.BufferedWriter的flush()方法：若写入的文本长度未达到缓冲区自动发送的容量，还必须使用flush()方法强制把缓冲区的数据发送入流中。
	 * 7.PrintWriter的构造方法后加上true，使之有自动行刷新的功能，没有则不能传输数据。
	 * 8.PrintWriter的println()方法：写入字符串，并通过写入行分隔符字符串终止当前行，带自动换行。
	 * 9.BufferedReader br=new BufferedReader(new InputStreamReader(socket.getInputStream()));
	 * 10.输入 与 输出 是以java虚拟机自身为参照物的
	 * 
	 * 网络通讯:
	 * 1.socket保存的数据是以字节流保存的
	 * 2.输出流是先将输出数据保存到socket对象，然后向客户端与服务器端传递对象，最后再用输入流读取保存在对象中的数据。
	 * 
	 * 
	 * 
	 * Java集合:
	 * 1.最高父类接口：Collection、Map
	 * 2.Collection常用集合：HashSet、TreeSet;ArryDeque;ArryList、LinkedList
	 *   Map常用集合：HashMap
	 * 3.Set集合数据无序存放，不可重复、List集合数据根据索引存放、Map集合数据键值对形式无序存放。
	 * 4.一个集合里一般只存同一种数据类型。
	 * 
	 * 
	 * 线程:
	 * 1.优先级高的进程将获得更多的执行机会
	 * 2.优先级：	MAX_PRIORITY 其值为10
	 * 			NORM_PRIORITY 其值为5
	 * 			MIN_PRIORITY 其值为1
	 * 			Main线程的优先级为中
	 * 3.每个不同的对象调用.start()方法,都能生成一个新的线程
	 * 4.可以[同时存在]多个run()方法，将它们写在[不同的类]，再在同一个[测试类]调用各自对象的.start()
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 */

}
